// Generated by CoffeeScript 2.7.0
(function() {
  var Bone, BoneMotion, CameraMotion, IK, Joint, LightMotion, Material, ModelMotion, Morph, MorphMotion, RigidBody, SelfShadowMotion, Vertex, bezierp, checkSize, fraction, ipfunc, ipfuncd, lerp1, loadImage, previousRegisteredFrame, size_Float32, size_Int8, size_Uint16, size_Uint32, size_Uint8, slice,
    indexOf = [].indexOf;

  this.MMD = class MMD {
    constructor(canvas, width, height) {
      this.width = width;
      this.height = height;
      this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!this.gl) {
        alert('WebGL not supported in your browser');
        throw 'WebGL not supported';
      }
    }

    initShaders() {
      var attributes, fshader, k, len, len1, len2, len3, line, name, o, ref, ref1, ref2, s, src, type, u, uniforms, vshader;
      vshader = this.gl.createShader(this.gl.VERTEX_SHADER);
      this.gl.shaderSource(vshader, MMD.VertexShaderSource);
      this.gl.compileShader(vshader);
      if (!this.gl.getShaderParameter(vshader, this.gl.COMPILE_STATUS)) {
        alert('Vertex shader compilation error');
        throw this.gl.getShaderInfoLog(vshader);
      }
      fshader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      this.gl.shaderSource(fshader, MMD.FragmentShaderSource);
      this.gl.compileShader(fshader);
      if (!this.gl.getShaderParameter(fshader, this.gl.COMPILE_STATUS)) {
        alert('Fragment shader compilation error');
        throw this.gl.getShaderInfoLog(fshader);
      }
      this.program = this.gl.createProgram();
      this.gl.attachShader(this.program, vshader);
      this.gl.attachShader(this.program, fshader);
      this.gl.linkProgram(this.program);
      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        alert('Shader linking error');
        throw this.gl.getProgramInfoLog(this.program);
      }
      this.gl.useProgram(this.program);
      attributes = [];
      uniforms = [];
      ref = [MMD.VertexShaderSource, MMD.FragmentShaderSource];
      for (k = 0, len = ref.length; k < len; k++) {
        src = ref[k];
        ref1 = src.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/[^\n]*/g, '').split(';');
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          line = ref1[o];
          type = (ref2 = line.match(/^\s*(uniform|attribute)\s+/)) != null ? ref2[1] : void 0;
          if (!type) {
            continue;
          }
          name = line.match(/(\w+)(\[\d+\])?\s*$/)[1];
          if (type === 'attribute' && indexOf.call(attributes, name) < 0) {
            attributes.push(name);
          }
          if (type === 'uniform' && indexOf.call(uniforms, name) < 0) {
            uniforms.push(name);
          }
        }
      }
      for (s = 0, len2 = attributes.length; s < len2; s++) {
        name = attributes[s];
        this.program[name] = this.gl.getAttribLocation(this.program, name);
        this.gl.enableVertexAttribArray(this.program[name]);
      }
      for (u = 0, len3 = uniforms.length; u < len3; u++) {
        name = uniforms[u];
        this.program[name] = this.gl.getUniformLocation(this.program, name);
      }
    }

    addModel(model) {
      this.model = model; // TODO: multi model?
    }

    initBuffers() {
      this.vbuffers = {};
      this.initVertices();
      this.initIndices();
      this.initTextures();
    }

    initVertices() {
      var bone1, bone2, buffer, data, edge, i, k, len, length, model, morphVec, normals, o, positions1, positions2, ref, ref1, rotations1, rotations2, uvs, vectors1, vectors2, vertex, weight;
      model = this.model;
      length = model.vertices.length;
      weight = new Float32Array(length);
      vectors1 = new Float32Array(3 * length);
      vectors2 = new Float32Array(3 * length);
      rotations1 = new Float32Array(4 * length);
      rotations2 = new Float32Array(4 * length);
      positions1 = new Float32Array(3 * length);
      positions2 = new Float32Array(3 * length);
      morphVec = new Float32Array(3 * length);
      normals = new Float32Array(3 * length);
      uvs = new Float32Array(2 * length);
      edge = new Float32Array(length);
      for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        vertex = model.vertices[i];
        bone1 = model.bones[vertex.bone_num1];
        bone2 = model.bones[vertex.bone_num2];
        weight[i] = vertex.bone_weight;
        vectors1[3 * i] = vertex.x - bone1.head_pos[0];
        vectors1[3 * i + 1] = vertex.y - bone1.head_pos[1];
        vectors1[3 * i + 2] = vertex.z - bone1.head_pos[2];
        vectors2[3 * i] = vertex.x - bone2.head_pos[0];
        vectors2[3 * i + 1] = vertex.y - bone2.head_pos[1];
        vectors2[3 * i + 2] = vertex.z - bone2.head_pos[2];
        positions1[3 * i] = bone1.head_pos[0];
        positions1[3 * i + 1] = bone1.head_pos[1];
        positions1[3 * i + 2] = bone1.head_pos[2];
        positions2[3 * i] = bone2.head_pos[0];
        positions2[3 * i + 1] = bone2.head_pos[1];
        positions2[3 * i + 2] = bone2.head_pos[2];
        rotations1[4 * i + 3] = 1;
        rotations2[4 * i + 3] = 1;
        normals[3 * i] = vertex.nx;
        normals[3 * i + 1] = vertex.ny;
        normals[3 * i + 2] = vertex.nz;
        uvs[2 * i] = vertex.u;
        uvs[2 * i + 1] = vertex.v;
        edge[i] = 1 - vertex.edge_flag;
      }
      model.rotations1 = rotations1;
      model.rotations2 = rotations2;
      model.positions1 = positions1;
      model.positions2 = positions2;
      model.morphVec = morphVec;
      ref1 = [
        {
          attribute: 'aBoneWeight',
          array: weight,
          size: 1
        },
        {
          attribute: 'aVectorFromBone1',
          array: vectors1,
          size: 3
        },
        {
          attribute: 'aVectorFromBone2',
          array: vectors2,
          size: 3
        },
        {
          attribute: 'aBone1Rotation',
          array: rotations1,
          size: 4
        },
        {
          attribute: 'aBone2Rotation',
          array: rotations2,
          size: 4
        },
        {
          attribute: 'aBone1Position',
          array: positions1,
          size: 3
        },
        {
          attribute: 'aBone2Position',
          array: positions2,
          size: 3
        },
        {
          attribute: 'aMultiPurposeVector',
          array: morphVec,
          size: 3
        },
        {
          attribute: 'aVertexNormal',
          array: normals,
          size: 3
        },
        {
          attribute: 'aTextureCoord',
          array: uvs,
          size: 2
        },
        {
          attribute: 'aVertexEdge',
          array: edge,
          size: 1
        }
      ];
      for (o = 0, len = ref1.length; o < len; o++) {
        data = ref1[o];
        buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, data.array, this.gl.STATIC_DRAW);
        this.vbuffers[data.attribute] = {
          size: data.size,
          buffer: buffer
        };
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    }

    initIndices() {
      var indices;
      indices = this.model.triangles;
      this.ibuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
    }

    initTextures() {
      var fileName, k, len, len1, material, model, o, ref, ref1, toonIndex, type;
      model = this.model;
      this.textureManager = new MMD.TextureManager(this);
      this.textureManager.onload = () => {
        return this.redraw = true;
      };
      ref = model.materials;
      for (k = 0, len = ref.length; k < len; k++) {
        material = ref[k];
        if (!material.textures) {
          material.textures = {};
        }
        toonIndex = material.toon_index;
        fileName = 'toon' + ('0' + (toonIndex + 1)).slice(-2) + '.bmp';
        if (toonIndex === -1 || !model.toon_file_names || fileName === model.toon_file_names[toonIndex]) {
          fileName = 'data/' + fileName; // otherwise the toon texture is in the model's directory
        } else {
          fileName = model.directory + '/' + model.toon_file_names[toonIndex];
        }
        material.textures.toon = this.textureManager.get('toon', fileName);
        if (material.texture_file_name) {
          ref1 = material.texture_file_name.split('*');
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            fileName = ref1[o];
            switch (fileName.slice(-4)) {
              case '.sph':
                type = 'sph';
                break;
              case '.spa':
                type = 'spa';
                break;
              case '.tga':
                type = 'regular';
                fileName += '.png';
                break;
              default:
                type = 'regular';
            }
            material.textures[type] = this.textureManager.get(type, model.directory + '/' + fileName);
          }
        }
      }
    }

    start() {
      var before, count, interval, step, t0;
      this.gl.clearColor(1, 1, 1, 1);
      this.gl.clearDepth(1);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.redraw = true;
      if (this.drawSelfShadow) {
        this.shadowMap = new MMD.ShadowMap(this);
      }
      this.motionManager = new MMD.MotionManager();
      count = 0;
      t0 = before = Date.now();
      interval = 1000 / this.fps;
      step = () => {
        var now;
        this.move();
        this.computeMatrices();
        this.render();
        now = Date.now();
        if (++count % this.fps === 0) {
          this.realFps = this.fps / (now - before) * 1000;
          before = now;
        }
        return setTimeout(step, (t0 + count * interval) - now); // target_time - now
      };
      step();
    }

    move() {
      if (!this.playing || this.textureManager.pendingCount > 0) {
        return;
      }
      if (++this.frame > this.motionManager.lastFrame) {
        this.pause();
        this.frame = -1;
        return;
      }
      this.moveCamera();
      this.moveLight();
      this.moveModel();
    }

    moveCamera() {
      var camera;
      camera = this.motionManager.getCameraFrame(this.frame);
      if (camera && !this.ignoreCameraMotion) {
        this.distance = camera.distance;
        this.rotx = camera.rotation[0];
        this.roty = camera.rotation[1];
        this.center = vec3.create(camera.location);
        this.fovy = camera.view_angle;
      }
    }

    moveLight() {
      var light;
      light = this.motionManager.getLightFrame(this.frame);
      if (light) {
        this.lightDirection = light.location;
        this.lightColor = light.color;
      }
    }

    moveModel() {
      var bones, model, morphs;
      model = this.model;
      ({morphs, bones} = this.motionManager.getModelFrame(model, this.frame));
      this.moveMorphs(model, morphs);
      this.moveBones(model, bones);
    }

    moveMorphs(model, morphs) {
      var b, base, i, j, k, len, len1, len2, morph, o, ref, ref1, ref2, s, vert, weight;
      if (!morphs) {
        return;
      }
      if (model.morphs.length === 0) {
        return;
      }
      ref = model.morphs;
      for (j = k = 0, len = ref.length; k < len; j = ++k) {
        morph = ref[j];
        if (j === 0) {
          base = morph;
          continue;
        }
        if (!(morph.name in morphs)) {
          continue;
        }
        weight = morphs[morph.name];
        ref1 = morph.vert_data;
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          vert = ref1[o];
          b = base.vert_data[vert.index];
          i = b.index;
          model.morphVec[3 * i] += vert.x * weight;
          model.morphVec[3 * i + 1] += vert.y * weight;
          model.morphVec[3 * i + 2] += vert.z * weight;
        }
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aMultiPurposeVector.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, model.morphVec, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      ref2 = base.vert_data;
      // reset positions
      for (s = 0, len2 = ref2.length; s < len2; s++) {
        b = ref2[s];
        i = b.index;
        model.morphVec[3 * i] = 0;
        model.morphVec[3 * i + 1] = 0;
        model.morphVec[3 * i + 2] = 0;
      }
    }

    moveBones(model, bones) {
      var bone, boneMotions, constrainedBones, getBoneMotion, i, individualBoneMotions, k, len, length, motion1, motion2, o, originalBonePositions, parentBones, pos1, pos2, positions1, positions2, ref, ref1, ref2, ref3, resolveIKs, rot1, rot2, rotations1, rotations2, s, vertex;
      if (!bones) {
        return;
      }
      // individualBoneMotions is translation/rotation of each bone from it's original position
      // boneMotions is total position/rotation of each bone
      // boneMotions is an array like [{p, r, tainted}]
      // tainted flag is used to avoid re-creating vec3/quat4
      individualBoneMotions = [];
      boneMotions = [];
      originalBonePositions = [];
      parentBones = [];
      constrainedBones = [];
      ref = model.bones;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        bone = ref[i];
        individualBoneMotions[i] = (ref1 = bones[bone.name]) != null ? ref1 : {
          rotation: quat4.create([0, 0, 0, 1]),
          location: vec3.create()
        };
        boneMotions[i] = {
          r: quat4.create(),
          p: vec3.create(),
          tainted: true
        };
        originalBonePositions[i] = bone.head_pos;
        parentBones[i] = bone.parent_bone_index;
        if (bone.name.indexOf('\u3072\u3056') > 0) { // ひざ
          constrainedBones[i] = true; // TODO: for now it's only for knees, but extend this if I do PMX
        }
      }
      getBoneMotion = function(boneIndex) {
        var m, motion, p, parentIndex, parentMotion, r, t;
        // http://d.hatena.ne.jp/edvakf/20111026/1319656727
        motion = boneMotions[boneIndex];
        if (motion && !motion.tainted) {
          return motion;
        }
        m = individualBoneMotions[boneIndex];
        r = quat4.set(m.rotation, motion.r);
        t = m.location;
        p = vec3.set(originalBonePositions[boneIndex], motion.p);
        if (parentBones[boneIndex] === 0xFFFF) { // center, foot IK, etc.
          return boneMotions[boneIndex] = {
            p: vec3.add(p, t),
            r: r,
            tainted: false
          };
        } else {
          parentIndex = parentBones[boneIndex];
          parentMotion = getBoneMotion(parentIndex);
          r = quat4.multiply(parentMotion.r, r, r);
          p = vec3.subtract(p, originalBonePositions[parentIndex]);
          vec3.add(p, t);
          vec3.rotateByQuat4(p, parentMotion.r);
          vec3.add(p, parentMotion.p);
          return boneMotions[boneIndex] = {
            p: p,
            r: r,
            tainted: false
          };
        }
      };
      resolveIKs = function() {
        var axis, axisLen, boneIndex, bonePos, c, ik, ikbonePos, ikboneVec, ikboneVecLen, j, len1, maxangle, minLength, motion, n, o, parentRotation, q, r, ref2, results, sinTheta, targetIndex, targetPos, targetVec, targetVecLen, theta, tmpQ, tmpR;
        // this function is run only once, but to narrow the scope I'm making a function
        // http://d.hatena.ne.jp/edvakf/20111102/1320268602

        // objects to be reused
        targetVec = vec3.create();
        ikboneVec = vec3.create();
        axis = vec3.create();
        tmpQ = quat4.create();
        tmpR = quat4.create();
        ref2 = model.iks;
        results = [];
        for (o = 0, len1 = ref2.length; o < len1; o++) {
          ik = ref2[o];
          ikbonePos = getBoneMotion(ik.bone_index).p;
          targetIndex = ik.target_bone_index;
          minLength = 0.1 * vec3.length(vec3.subtract(originalBonePositions[targetIndex], originalBonePositions[parentBones[targetIndex]], axis)); // temporary use of axis
          results.push((function() {
            var ref3, results1, s;
            results1 = [];
            for (n = s = 0, ref3 = ik.iterations; (0 <= ref3 ? s < ref3 : s > ref3); n = 0 <= ref3 ? ++s : --s) {
              targetPos = getBoneMotion(targetIndex).p; // this should calculate the whole chain
              if (minLength > vec3.length(vec3.subtract(targetPos, ikbonePos, axis))) { // temporary use of axis
                break;
              }
              results1.push((function() {
                var len2, ref4, ref5, results2, u, z;
                ref4 = ik.child_bones;
                results2 = [];
                for (i = u = 0, len2 = ref4.length; u < len2; i = ++u) {
                  boneIndex = ref4[i];
                  motion = getBoneMotion(boneIndex);
                  bonePos = motion.p;
                  if (i > 0) {
                    targetPos = getBoneMotion(targetIndex).p;
                  }
                  targetVec = vec3.subtract(targetPos, bonePos, targetVec);
                  targetVecLen = vec3.length(targetVec);
                  if (targetVecLen < minLength) { // targetPos == bonePos
                    continue;
                  }
                  ikboneVec = vec3.subtract(ikbonePos, bonePos, ikboneVec);
                  ikboneVecLen = vec3.length(ikboneVec);
                  if (ikboneVecLen < minLength) { // ikbonePos == bonePos
                    continue;
                  }
                  axis = vec3.cross(targetVec, ikboneVec, axis);
                  axisLen = vec3.length(axis);
                  sinTheta = axisLen / ikboneVecLen / targetVecLen;
                  if (sinTheta < 0.001) { // ~0.05 degree
                    continue;
                  }
                  maxangle = (i + 1) * ik.control_weight * 4; // angle to move in one iteration
                  theta = Math.asin(sinTheta);
                  if (vec3.dot(targetVec, ikboneVec) < 0) {
                    theta = 3.141592653589793 - theta;
                  }
                  if (theta > maxangle) {
                    theta = maxangle;
                  }
                  q = quat4.set(vec3.scale(axis, Math.sin(theta / 2) / axisLen), tmpQ); // q is tmpQ
                  q[3] = Math.cos(theta / 2);
                  parentRotation = getBoneMotion(parentBones[boneIndex]).r;
                  r = quat4.inverse(parentRotation, tmpR); // r is tmpR
                  r = quat4.multiply(quat4.multiply(r, q), motion.r);
                  if (constrainedBones[boneIndex]) {
                    c = r[3];
                    r = quat4.set([Math.sqrt(1 - c * c), 0, 0, c], r); // axis must be x direction
                    quat4.inverse(boneMotions[boneIndex].r, q);
                    quat4.multiply(r, q, q);
                    q = quat4.multiply(parentRotation, q, q);
                  }
                  // update individualBoneMotions[boneIndex].rotation
                  quat4.normalize(r, individualBoneMotions[boneIndex].rotation);
                  // update boneMotions[boneIndex].r which is the same as motion.r
                  quat4.multiply(q, motion.r, motion.r);
                  for (j = z = 0, ref5 = i; (0 <= ref5 ? z < ref5 : z > ref5); j = 0 <= ref5 ? ++z : --z) {
                    // taint for re-calculation
                    boneMotions[ik.child_bones[j]].tainted = true;
                  }
                  results2.push(boneMotions[ik.target_bone_index].tainted = true);
                }
                return results2;
              })());
            }
            return results1;
          })());
        }
        return results;
      };
      resolveIKs();
      for (i = o = 0, ref2 = model.bones.length; (0 <= ref2 ? o < ref2 : o > ref2); i = 0 <= ref2 ? ++o : --o) {
        // calculate positions/rotations of bones other than IK
        getBoneMotion(i);
      }
      //TODO: split
      rotations1 = model.rotations1;
      rotations2 = model.rotations2;
      positions1 = model.positions1;
      positions2 = model.positions2;
      length = model.vertices.length;
      for (i = s = 0, ref3 = length; (0 <= ref3 ? s < ref3 : s > ref3); i = 0 <= ref3 ? ++s : --s) {
        vertex = model.vertices[i];
        motion1 = boneMotions[vertex.bone_num1];
        motion2 = boneMotions[vertex.bone_num2];
        rot1 = motion1.r;
        pos1 = motion1.p;
        rot2 = motion2.r;
        pos2 = motion2.p;
        rotations1[i * 4] = rot1[0];
        rotations1[i * 4 + 1] = rot1[1];
        rotations1[i * 4 + 2] = rot1[2];
        rotations1[i * 4 + 3] = rot1[3];
        rotations2[i * 4] = rot2[0];
        rotations2[i * 4 + 1] = rot2[1];
        rotations2[i * 4 + 2] = rot2[2];
        rotations2[i * 4 + 3] = rot2[3];
        positions1[i * 3] = pos1[0];
        positions1[i * 3 + 1] = pos1[1];
        positions1[i * 3 + 2] = pos1[2];
        positions2[i * 3] = pos2[0];
        positions2[i * 3 + 1] = pos2[1];
        positions2[i * 3 + 2] = pos2[2];
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Rotation.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations1, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Rotation.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations2, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Position.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, positions1, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Position.buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, positions2, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    }

    computeMatrices() {
      var up;
      this.modelMatrix = mat4.createIdentity(); // model aligned with the world for now
      this.cameraPosition = vec3.create([
        0,
        0,
        this.distance // camera position in world space
      ]);
      vec3.rotateX(this.cameraPosition, this.rotx);
      vec3.rotateY(this.cameraPosition, this.roty);
      vec3.moveBy(this.cameraPosition, this.center);
      up = [0, 1, 0];
      vec3.rotateX(up, this.rotx);
      vec3.rotateY(up, this.roty);
      this.viewMatrix = mat4.lookAt(this.cameraPosition, this.center, up);
      this.mvMatrix = mat4.createMultiply(this.viewMatrix, this.modelMatrix);
      this.pMatrix = mat4.perspective(this.fovy, this.width / this.height, 0.1, 1000.0);
      // normal matrix; inverse transpose of mvMatrix
      // model -> view space; only applied to directional vectors (not points)
      this.nMatrix = mat4.inverseTranspose(this.mvMatrix, mat4.create());
    }

    render() {
      var attribute, k, len, len1, material, o, offset, ref, ref1, ref2, vb;
      if (!this.redraw && !this.playing) {
        return;
      }
      this.redraw = false;
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      this.gl.viewport(0, 0, this.width, this.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.vbuffers;
      for (attribute in ref) {
        vb = ref[attribute];
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vb.buffer);
        this.gl.vertexAttribPointer(this.program[attribute], vb.size, this.gl.FLOAT, false, 0, 0);
      }
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
      this.setSelfShadowTexture();
      this.setUniforms();
      this.gl.enable(this.gl.CULL_FACE);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.SRC_ALPHA, this.gl.DST_ALPHA);
      offset = 0;
      ref1 = this.model.materials;
      for (k = 0, len = ref1.length; k < len; k++) {
        material = ref1[k];
        this.renderMaterial(material, offset);
        offset += material.face_vert_count;
      }
      this.gl.disable(this.gl.BLEND);
      offset = 0;
      ref2 = this.model.materials;
      for (o = 0, len1 = ref2.length; o < len1; o++) {
        material = ref2[o];
        this.renderEdge(material, offset);
        offset += material.face_vert_count;
      }
      this.gl.disable(this.gl.CULL_FACE);
      this.renderAxes();
      this.gl.flush();
    }

    setSelfShadowTexture() {
      var k, len, material, model, offset, ref, ref1;
      if (!this.drawSelfShadow) {
        return;
      }
      model = this.model;
      this.shadowMap.computeMatrices();
      this.shadowMap.beforeRender();
      offset = 0;
      ref = model.materials;
      for (k = 0, len = ref.length; k < len; k++) {
        material = ref[k];
        if ((0.979 < (ref1 = material.alpha) && ref1 < 0.981)) { // alpha is 0.98
          continue;
        }
        this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
        offset += material.face_vert_count;
      }
      this.shadowMap.afterRender();
      this.gl.activeTexture(this.gl.TEXTURE3); // 3 -> shadow map
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.shadowMap.getTexture());
      this.gl.uniform1i(this.program.uShadowMap, 3);
      this.gl.uniformMatrix4fv(this.program.uLightMatrix, false, this.shadowMap.getLightMatrix());
      this.gl.uniform1i(this.program.uSelfShadow, true);
      // reset
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      this.gl.viewport(0, 0, this.width, this.height); // not needed on Windows Chrome but necessary on Mac Chrome
    }

    setUniforms() {
      var lightDirection;
      this.gl.uniform1f(this.program.uEdgeThickness, this.edgeThickness);
      this.gl.uniform3fv(this.program.uEdgeColor, this.edgeColor);
      this.gl.uniformMatrix4fv(this.program.uMVMatrix, false, this.mvMatrix);
      this.gl.uniformMatrix4fv(this.program.uPMatrix, false, this.pMatrix);
      this.gl.uniformMatrix4fv(this.program.uNMatrix, false, this.nMatrix);
      // direction of light source defined in world space, then transformed to view space
      lightDirection = vec3.createNormalize(this.lightDirection); // world space
      mat4.multiplyVec3(this.nMatrix, lightDirection); // view space
      this.gl.uniform3fv(this.program.uLightDirection, lightDirection);
      this.gl.uniform3fv(this.program.uLightColor, this.lightColor);
    }

    renderMaterial(material, offset) {
      var textures;
      this.gl.uniform3fv(this.program.uAmbientColor, material.ambient);
      this.gl.uniform3fv(this.program.uSpecularColor, material.specular);
      this.gl.uniform3fv(this.program.uDiffuseColor, material.diffuse);
      this.gl.uniform1f(this.program.uAlpha, material.alpha);
      this.gl.uniform1f(this.program.uShininess, material.shininess);
      this.gl.uniform1i(this.program.uEdge, false);
      textures = material.textures;
      this.gl.activeTexture(this.gl.TEXTURE0); // 0 -> toon
      this.gl.bindTexture(this.gl.TEXTURE_2D, textures.toon);
      this.gl.uniform1i(this.program.uToon, 0);
      if (textures.regular) {
        this.gl.activeTexture(this.gl.TEXTURE1); // 1 -> regular texture
        this.gl.bindTexture(this.gl.TEXTURE_2D, textures.regular);
        this.gl.uniform1i(this.program.uTexture, 1);
      }
      this.gl.uniform1i(this.program.uUseTexture, !!textures.regular);
      if (textures.sph || textures.spa) {
        this.gl.activeTexture(this.gl.TEXTURE2); // 2 -> sphere map texture
        this.gl.bindTexture(this.gl.TEXTURE_2D, textures.sph || textures.spa);
        this.gl.uniform1i(this.program.uSphereMap, 2);
        this.gl.uniform1i(this.program.uUseSphereMap, true);
        this.gl.uniform1i(this.program.uIsSphereMapAdditive, !!textures.spa);
      } else {
        this.gl.uniform1i(this.program.uUseSphereMap, false);
      }
      this.gl.cullFace(this.gl.BACK);
      this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
    }

    renderEdge(material, offset) {
      if (!this.drawEdge || !material.edge_flag) {
        return;
      }
      this.gl.uniform1i(this.program.uEdge, true);
      this.gl.cullFace(this.gl.FRONT);
      this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
      this.gl.cullFace(this.gl.BACK);
      return this.gl.uniform1i(this.program.uEdge, false);
    }

    renderAxes() {
      var axis, axisBuffer, color, i, k, o;
      axisBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, axisBuffer);
      this.gl.vertexAttribPointer(this.program.aMultiPurposeVector, 3, this.gl.FLOAT, false, 0, 0);
      if (this.drawAxes) {
        this.gl.uniform1i(this.program.uAxis, true);
        for (i = k = 0; k < 3; i = ++k) {
          axis = [0, 0, 0, 0, 0, 0];
          axis[i] = 65; // from [65, 0, 0] to [0, 0, 0] etc.
          color = [0, 0, 0];
          color[i] = 1;
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axis), this.gl.STATIC_DRAW);
          this.gl.uniform3fv(this.program.uAxisColor, color);
          this.gl.drawArrays(this.gl.LINES, 0, 2);
        }
        axis = [
          -50,
          0,
          0,
          0,
          0,
          0, // negative x-axis (from [-50, 0, 0] to origin)
          0,
          0,
          -50,
          0,
          0,
          0 // negative z-axis (from [0, 0, -50] to origin)
        ];
        for (i = o = -50; o <= 50; i = o += 5) {
          if (i !== 0) {
            axis.push(i, 0, -50, i, 0, 50, -50, 0, i, 50, 0, i); // one line parallel to the x-axis // one line parallel to the z-axis
          }
        }
        color = [0.7, 0.7, 0.7];
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(axis), this.gl.STATIC_DRAW);
        this.gl.uniform3fv(this.program.uAxisColor, color);
        this.gl.drawArrays(this.gl.LINES, 0, 84);
        this.gl.uniform1i(this.program.uAxis, false);
      }
      // draw center point
      if (this.drawCenterPoint) {
        this.gl.uniform1i(this.program.uCenterPoint, true);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.center), this.gl.STATIC_DRAW);
        this.gl.drawArrays(this.gl.POINTS, 0, 1);
        this.gl.uniform1i(this.program.uCenterPoint, false);
      }
      this.gl.deleteBuffer(axisBuffer);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    }

    registerKeyListener(element) {
      element.addEventListener('keydown', (e) => {
        switch (e.keyCode + e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000) {
          case 37:
            this.roty += Math.PI / 12; // left
            break;
          case 39:
            this.roty -= Math.PI / 12; // right
            break;
          case 38:
            this.rotx += Math.PI / 12; // up
            break;
          case 40:
            this.rotx -= Math.PI / 12; // down
            break;
          case 33:
            this.distance -= 3 * this.distance / this.DIST; // pageup
            break;
          case 34:
            this.distance += 3 * this.distance / this.DIST; // pagedown
            break;
          case 36: // home
            this.rotx = this.roty = 0;
            this.center = [0, 10, 0];
            this.distance = this.DIST;
            break;
          case 1037: // shift + left
            vec3.multiplyMat4(this.center, this.mvMatrix);
            this.center[0] -= this.distance / this.DIST;
            vec3.multiplyMat4(this.center, mat4.createInverse(this.mvMatrix));
            break;
          case 1039: // shift + right
            vec3.multiplyMat4(this.center, this.mvMatrix);
            this.center[0] += this.distance / this.DIST;
            vec3.multiplyMat4(this.center, mat4.createInverse(this.mvMatrix));
            break;
          case 1038: // shift +  up
            vec3.multiplyMat4(this.center, this.mvMatrix);
            this.center[1] += this.distance / this.DIST;
            vec3.multiplyMat4(this.center, mat4.createInverse(this.mvMatrix));
            break;
          case 1040: // shift + down
            vec3.multiplyMat4(this.center, this.mvMatrix);
            this.center[1] -= this.distance / this.DIST;
            vec3.multiplyMat4(this.center, mat4.createInverse(this.mvMatrix));
            break;
          case 32: // space
            if (this.playing) {
              this.pause();
            } else {
              this.play();
            }
            break;
          default:
            return;
        }
        e.preventDefault();
        return this.redraw = true;
      }, false);
    }

    registerMouseListener(element) {
      this.registerDragListener(element);
      this.registerWheelListener(element);
    }

    registerDragListener(element) {
      element.addEventListener('mousedown', (e) => {
        var modifier, move, onmousemove, onmouseup, ox, oy;
        if (e.button !== 0) {
          return;
        }
        modifier = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
        if (modifier !== 0 && modifier !== 1000) {
          return;
        }
        ox = e.clientX;
        oy = e.clientY;
        move = (dx, dy, modi) => {
          if (modi === 0) {
            this.roty -= dx / 100;
            this.rotx -= dy / 100;
            return this.redraw = true;
          } else if (modi === 1000) {
            vec3.multiplyMat4(this.center, this.mvMatrix);
            this.center[0] -= dx / 30 * this.distance / this.DIST;
            this.center[1] += dy / 30 * this.distance / this.DIST;
            vec3.multiplyMat4(this.center, mat4.createInverse(this.mvMatrix));
            return this.redraw = true;
          }
        };
        onmouseup = (e) => {
          var modi;
          if (e.button !== 0) {
            return;
          }
          modi = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
          move(e.clientX - ox, e.clientY - oy, modi);
          element.removeEventListener('mouseup', onmouseup, false);
          element.removeEventListener('mousemove', onmousemove, false);
          return e.preventDefault();
        };
        onmousemove = (e) => {
          var modi, x, y;
          if (e.button !== 0) {
            return;
          }
          modi = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
          x = e.clientX;
          y = e.clientY;
          move(x - ox, y - oy, modi);
          ox = x;
          oy = y;
          return e.preventDefault();
        };
        element.addEventListener('mouseup', onmouseup, false);
        return element.addEventListener('mousemove', onmousemove, false);
      }, false);
    }

    registerWheelListener(element) {
      var onwheel;
      onwheel = (e) => {
        var delta;
        delta = e.detail || e.wheelDelta / (-40); // positive: wheel down
        this.distance += delta * this.distance / this.DIST;
        this.redraw = true;
        return e.preventDefault();
      };
      if ('onmousewheel' in window) {
        element.addEventListener('mousewheel', onwheel, false);
      } else {
        element.addEventListener('DOMMouseScroll', onwheel, false);
      }
    }

    initParameters() {
      // camera/view settings
      this.ignoreCameraMotion = false;
      this.rotx = this.roty = 0;
      this.distance = this.DIST = 35;
      this.center = [0, 10, 0];
      this.fovy = 40;
      // edge
      this.drawEdge = true;
      this.edgeThickness = 0.004;
      this.edgeColor = [0, 0, 0];
      // light
      this.lightDirection = [0.5, 1.0, 0.5];
      this.lightDistance = 8875;
      this.lightColor = [0.6, 0.6, 0.6];
      // misc
      this.drawSelfShadow = true;
      this.drawAxes = true;
      this.drawCenterPoint = false;
      this.fps = 30; // redraw every 1000/30 msec
      this.realFps = this.fps;
      this.playing = false;
      this.frame = -1;
    }

    addCameraLightMotion(motion, merge_flag, frame_offset) {
      this.motionManager.addCameraLightMotion(motion, merge_flag, frame_offset);
    }

    addModelMotion(model, motion, merge_flag, frame_offset) {
      this.motionManager.addModelMotion(model, motion, merge_flag, frame_offset);
    }

    play() {
      this.playing = true;
    }

    pause() {
      this.playing = false;
    }

    rewind() {
      this.setFrameNumber(-1);
    }

    setFrameNumber(num) {
      this.frame = num;
    }

  };

  this.MMD.AudioSource = class AudioSource { // export to top level
    constructor(directory, filename, volume) {
      this.directory = directory;
      this.filename = filename;
      this.volume = volume;
    }

    load(callback) {
      if (this.loaded) {
        callback();
        return;
      }
      this.music = new Audio(this.directory + '/' + this.filename);
      this.music.load();
      return this.music.addEventListener('canplaythrough', () => {
        this.loaded = true;
        return callback();
      });
    }

    play(name) {
      if (!this.music) {
        return console.error('no music');
      }
      this.music.volume = this.volume;
      return this.music.play();
    }

    stop() {
      if (!this.music) {
        return console.error('no music');
      }
      this.music.pause();
      return this.music.currentTime = 0;
    }

    pause() {
      if (!this.music) {
        return console.error('no music');
      }
      return this.music.pause();
    }

    resume() {
      if (!this.music) {
        return console.error('no music');
      }
      return this.music.play();
    }

    setVolume(volume) {
      if (!this.music) {
        return console.error('no music');
      }
      if (volume < 0) {
        volume = 0;
      }
      if (volume > 1) {
        volume = 1;
      }
      return this.music.volume = volume;
    }

  };

  MMD.FragmentShaderSource = `
#ifdef GL_ES
precision highp float;
#endif

varying vec2 vTextureCoord;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec4 vLightCoord;

uniform vec3 uLightDirection; // light source direction in world space
uniform vec3 uLightColor;

uniform vec3 uAmbientColor;
uniform vec3 uSpecularColor;
uniform vec3 uDiffuseColor;
uniform float uAlpha;
uniform float uShininess;

uniform bool uUseTexture;
uniform bool uUseSphereMap;
uniform bool uIsSphereMapAdditive;

uniform sampler2D uToon;
uniform sampler2D uTexture;
uniform sampler2D uSphereMap;

uniform bool uEdge;
uniform float uEdgeThickness;
uniform vec3 uEdgeColor;

uniform bool uGenerateShadowMap;
uniform bool uSelfShadow;
uniform sampler2D uShadowMap;

uniform bool uAxis;
uniform vec3 uAxisColor;
uniform bool uCenterPoint;

// from http://spidergl.org/example.php?id=6
vec4 pack_depth(const in float depth) {
  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
  vec4 res = fract(depth * bit_shift);
  res -= res.xxyz * bit_mask;
  return res;
}
float unpack_depth(const in vec4 rgba_depth)
{
  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
  float depth = dot(rgba_depth, bit_shift);
  return depth;
}

void main() {
  if (uGenerateShadowMap) {
    //gl_FragData[0] = pack_depth(gl_FragCoord.z);
    gl_FragColor = pack_depth(gl_FragCoord.z);
    return;
  }
  if (uAxis) {
    gl_FragColor = vec4(uAxisColor, 1.0);
    return;
  }
  if (uCenterPoint) {
    vec2 uv = gl_PointCoord * 2.0 - 1.0; // transform [0, 1] -> [-1, 1] coord systems
    float w = dot(uv, uv);
    if (w < 0.3 || (w > 0.5 && w < 1.0)) {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
      discard;
    }
    return;
  }

  // vectors are in view space
  vec3 norm = normalize(vNormal); // each point's normal vector in view space
  vec3 cameraDirection = normalize(-vPosition); // camera located at origin in view space

  vec3 color;
  float alpha = uAlpha;

  if (uEdge) {

    color = uEdgeColor;

  } else {

    color = vec3(1.0, 1.0, 1.0);
    if (uUseTexture) {
      vec4 texColor = texture2D(uTexture, vTextureCoord);
      color *= texColor.rgb;
      alpha *= texColor.a;
    }
    if (uUseSphereMap) {
      vec2 sphereCoord = 0.5 * (1.0 + vec2(1.0, -1.0) * norm.xy);
      if (uIsSphereMapAdditive) {
        color += texture2D(uSphereMap, sphereCoord).rgb;
      } else {
        color *= texture2D(uSphereMap, sphereCoord).rgb;
      }
    }

    // specular component
    vec3 halfAngle = normalize(uLightDirection + cameraDirection);
    float specularWeight = pow( max(0.001, dot(halfAngle, norm)) , uShininess );
    //float specularWeight = pow( max(0.0, dot(reflect(-uLightDirection, norm), cameraDirection)) , uShininess ); // another definition
    vec3 specular = specularWeight * uSpecularColor;

    vec2 toonCoord = vec2(0.0, 0.5 * (1.0 - dot( uLightDirection, norm )));

    if (uSelfShadow) {
      vec3 lightCoord = vLightCoord.xyz / vLightCoord.w; // projection to texture coordinate (in light space)
      vec4 rgbaDepth = texture2D(uShadowMap, lightCoord.xy);
      float depth = unpack_depth(rgbaDepth);
      if (depth < lightCoord.z - 0.01) {
        toonCoord = vec2(0.0, 0.55);
      }
    }

    color *= uAmbientColor + uLightColor * (uDiffuseColor + specular);

    color = clamp(color, 0.0, 1.0);
    color *= texture2D(uToon, toonCoord).rgb;

  }
  gl_FragColor = vec4(color, alpha);

}
`;

  // see http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4

  // some shorthands
  size_Int8 = Int8Array.BYTES_PER_ELEMENT;

  size_Uint8 = Uint8Array.BYTES_PER_ELEMENT;

  size_Uint16 = Uint16Array.BYTES_PER_ELEMENT;

  size_Uint32 = Uint32Array.BYTES_PER_ELEMENT;

  size_Float32 = Float32Array.BYTES_PER_ELEMENT;

  slice = Array.prototype.slice;

  this.MMD.Model = class Model { // export to top level
    constructor(directory, filename) {
      this.directory = directory;
      this.filename = filename;
      this.vertices = null;
      this.triangles = null;
      this.materials = null;
      this.bones = null;
      this.morphs = null;
      this.morph_order = null;
      this.bone_group_names = null;
      this.bone_table = null;
      this.english_flag = null;
      this.english_name = null;
      this.english_comment = null;
      this.english_bone_names = null;
      this.english_morph_names = null;
      this.english_bone_group_names = null;
      this.toon_file_names = null;
      this.rigid_bodies = null;
      this.joints = null;
    }

    load(callback) {
      var xhr;
      xhr = new XMLHttpRequest();
      xhr.open('GET', this.directory + '/' + this.filename, true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = () => {
        console.time('parse');
        this.parse(xhr.response);
        console.timeEnd('parse');
        return callback();
      };
      return xhr.send();
    }

    parse(buffer) {
      var length, offset, view;
      length = buffer.byteLength;
      view = new DataView(buffer, 0);
      offset = 0;
      offset = this.checkHeader(buffer, view, offset);
      offset = this.getName(buffer, view, offset);
      offset = this.getVertices(buffer, view, offset);
      offset = this.getTriangles(buffer, view, offset);
      offset = this.getMaterials(buffer, view, offset);
      offset = this.getBones(buffer, view, offset);
      offset = this.getIKs(buffer, view, offset);
      offset = this.getMorphs(buffer, view, offset);
      offset = this.getMorphOrder(buffer, view, offset);
      offset = this.getBoneGroupNames(buffer, view, offset);
      offset = this.getBoneTable(buffer, view, offset);
      if (offset >= length) {
        return;
      }
      offset = this.getEnglishFlag(buffer, view, offset);
      if (this.english_flag) {
        offset = this.getEnglishName(buffer, view, offset);
        offset = this.getEnglishBoneNames(buffer, view, offset);
        offset = this.getEnglishMorphNames(buffer, view, offset);
        offset = this.getEnglishBoneGroupNames(buffer, view, offset);
      }
      if (offset >= length) {
        return;
      }
      offset = this.getToonFileNames(buffer, view, offset);
      if (offset >= length) {
        return;
      }
      offset = this.getRigidBodies(buffer, view, offset);
      return offset = this.getJoints(buffer, view, offset);
    }

    checkHeader(buffer, view, offset) {
      if (view.getUint8(0) !== 'P'.charCodeAt(0) || view.getUint8(1) !== 'm'.charCodeAt(0) || view.getUint8(2) !== 'd'.charCodeAt(0) || view.getUint8(3) !== 0x00 || view.getUint8(4) !== 0x00 || view.getUint8(5) !== 0x80 || view.getUint8(6) !== 0x3F) {
        throw 'File is not PMD';
      }
      return offset += 7 * size_Uint8;
    }

    getName(buffer, view, offset) {
      var block;
      block = new Uint8Array(buffer, offset, 20 + 256);
      this.name = sjisArrayToString(slice.call(block, 0, 20));
      this.comment = sjisArrayToString(slice.call(block, 20, 20 + 256));
      return offset += (20 + 256) * size_Uint8;
    }

    getVertices(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.vertices = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new Vertex(buffer, view, offset + i * Vertex.size));
        }
        return results;
      })();
      return offset += length * Vertex.size;
    }

    getTriangles(buffer, view, offset) {
      var i, k, length, ref;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.triangles = new Uint16Array(length);
//left->right handed system (swap 0th and 1st vertices)
      for (i = k = 0, ref = length; k < ref; i = k += 3) {
        this.triangles[i + 1] = view.getUint16(offset + i * size_Uint16, true);
        this.triangles[i] = view.getUint16(offset + (i + 1) * size_Uint16, true);
        this.triangles[i + 2] = view.getUint16(offset + (i + 2) * size_Uint16, true);
      }
      return offset += length * size_Uint16;
    }

    getMaterials(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.materials = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new Material(buffer, view, offset + i * Material.size));
        }
        return results;
      })();
      return offset += length * Material.size;
    }

    getBones(buffer, view, offset) {
      var i, length;
      length = view.getUint16(offset, true);
      offset += size_Uint16;
      this.bones = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new Bone(buffer, view, offset + i * Bone.size));
        }
        return results;
      })();
      return offset += length * Bone.size;
    }

    getIKs(buffer, view, offset) {
      var i, ik, length;
      length = view.getUint16(offset, true);
      offset += size_Uint16;
      this.iks = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          ik = new IK(buffer, view, offset);
          offset += ik.getSize();
          results.push(ik);
        }
        return results;
      })();
      return offset;
    }

    getMorphs(buffer, view, offset) {
      var i, length, morph;
      length = view.getUint16(offset, true);
      offset += size_Uint16;
      this.morphs = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          morph = new Morph(buffer, view, offset);
          offset += morph.getSize();
          results.push(morph);
        }
        return results;
      })();
      return offset;
    }

    getMorphOrder(buffer, view, offset) {
      var i, length;
      length = view.getUint8(offset);
      offset += size_Uint8;
      this.morph_order = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(view.getUint16(offset + i * size_Uint16, true));
        }
        return results;
      })();
      return offset += length * size_Uint16;
    }

    getBoneGroupNames(buffer, view, offset) {
      var block, i, length;
      length = view.getUint8(offset);
      offset += size_Uint8;
      block = new Uint8Array(buffer, offset, 50 * length);
      this.bone_group_names = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(sjisArrayToString(slice.call(block, i * 50, (i + 1) * 50)));
        }
        return results;
      })();
      return offset += length * 50 * size_Uint8;
    }

    getBoneTable(buffer, view, offset) {
      var bone, i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.bone_table = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          bone = {};
          bone.index = view.getUint16(offset, true);
          offset += size_Uint16;
          bone.group_index = view.getUint8(offset);
          offset += size_Uint8;
          results.push(bone);
        }
        return results;
      })();
      return offset;
    }

    getEnglishFlag(buffer, view, offset) {
      this.english_flag = view.getUint8(offset);
      return offset += size_Uint8;
    }

    getEnglishName(buffer, view, offset) {
      var block;
      block = new Uint8Array(buffer, offset, 20 + 256);
      this.english_name = sjisArrayToString(slice.call(block, 0, 20));
      this.english_comment = sjisArrayToString(slice.call(block, 20, 20 + 256));
      return offset += (20 + 256) * size_Uint8;
    }

    getEnglishBoneNames(buffer, view, offset) {
      var block, i, length;
      length = this.bones.length;
      block = new Uint8Array(buffer, offset, 20 * length);
      this.english_bone_names = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(sjisArrayToString(slice.call(block, i * 20, (i + 1) * 20)));
        }
        return results;
      })();
      return offset += length * 20 * size_Uint8;
    }

    getEnglishMorphNames(buffer, view, offset) {
      var block, i, length;
      length = this.morphs.length - 1;
      if (length < 0) {
        length = 0;
      }
      block = new Uint8Array(buffer, offset, 20 * length);
      this.english_morph_names = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(sjisArrayToString(slice.call(block, i * 20, (i + 1) * 20)));
        }
        return results;
      })();
      return offset += length * 20 * size_Uint8;
    }

    getEnglishBoneGroupNames(buffer, view, offset) {
      var block, i, length;
      length = this.bone_group_names.length;
      block = new Uint8Array(buffer, offset, 50 * length);
      this.english_bone_group_names = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(sjisArrayToString(slice.call(block, i * 50, (i + 1) * 50)));
        }
        return results;
      })();
      return offset += length * 50 * size_Uint8;
    }

    getToonFileNames(buffer, view, offset) {
      var block, i;
      block = new Uint8Array(buffer, offset, 100 * 10);
      this.toon_file_names = (function() {
        var k, results;
        results = [];
        for (i = k = 0; k < 10; i = ++k) {
          results.push(sjisArrayToString(slice.call(block, i * 100, (i + 1) * 100)));
        }
        return results;
      })();
      return offset += 100 * 10 * size_Uint8;
    }

    getRigidBodies(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.rigid_bodies = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new RigidBody(buffer, view, offset + i * RigidBody.size));
        }
        return results;
      })();
      return offset += length * RigidBody.size;
    }

    getJoints(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.joints = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new Joint(buffer, view, offset + i * Joint.size));
        }
        return results;
      })();
      return offset += length * Joint.size;
    }

  };

  //http://blog.goo.ne.jp/torisu_tetosuki/e/5a1b16e2f61067838dfc66d010389707
  //float pos[3]; // x, y, z // 
  //float normal_vec[3]; // nx, ny, nz // 
  //float uv[2]; // u, v // UV // MMDUV
  //WORD bone_num[2]; // 12 // ()
  //BYTE bone_weight; // 1 // min:0 max:100 // 2(100 - bone_weight)
  //BYTE edge_flag; // 0:1: // ()
  Vertex = class Vertex {
    constructor(buffer, view, offset) {
      this.x = view.getFloat32(offset, true);
      offset += size_Float32;
      this.y = view.getFloat32(offset, true);
      offset += size_Float32;
      this.z = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.nx = view.getFloat32(offset, true);
      offset += size_Float32;
      this.ny = view.getFloat32(offset, true);
      offset += size_Float32;
      this.nz = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.u = view.getFloat32(offset, true);
      offset += size_Float32;
      this.v = view.getFloat32(offset, true);
      offset += size_Float32;
      this.bone_num1 = view.getUint16(offset, true);
      offset += size_Uint16;
      this.bone_num2 = view.getUint16(offset, true);
      offset += size_Uint16;
      this.bone_weight = view.getUint8(offset);
      offset += size_Uint8;
      this.edge_flag = view.getUint8(offset);
      offset += size_Uint8;
    }

  };

  Vertex.size = size_Float32 * 8 + size_Uint16 * 2 + size_Uint8 * 2; // 38

  
    //http://blog.goo.ne.jp/torisu_tetosuki/e/ea0bb1b1d4c6ad98a93edbfe359dac32
  //float diffuse_color[3]; // dr, dg, db // 
  //float alpha;
  //float specularity;
  //float specular_color[3]; // sr, sg, sb // 
  //float mirror_color[3]; // mr, mg, mb // (ambient)
  //BYTE toon_index; // toon??.bmp // 0.bmp:0xFF, 1(01).bmp:0x00  10.bmp:0x09
  //BYTE edge_flag; // 
  //DWORD face_vert_count; //  // 0
  //char texture_file_name[20]; //  // 20(0x00)
  Material = class Material {
    constructor(buffer, view, offset) {
      var i, tmp;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.diffuse = new Float32Array(tmp);
      this.alpha = view.getFloat32(offset, true);
      offset += size_Float32;
      this.shininess = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.specular = new Float32Array(tmp);
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.ambient = new Float32Array(tmp);
      this.toon_index = view.getInt8(offset);
      offset += size_Int8;
      this.edge_flag = view.getUint8(offset);
      offset += size_Uint8;
      this.face_vert_count = view.getUint32(offset, true);
      offset += size_Uint32;
      this.texture_file_name = sjisArrayToString((function() {
        var k, results;
        results = [];
        for (i = k = 0; k < 20; i = ++k) {
          results.push(view.getUint8(offset + size_Uint8 * i));
        }
        return results;
      })());
    }

  };

  Material.size = size_Float32 * 11 + size_Uint8 * 2 + size_Uint32 + size_Uint8 * 20; // 70

  
    //http://blog.goo.ne.jp/torisu_tetosuki/e/638463f52d0ad6ca1c46fd315a9b17d0
  //char bone_name[20]; // 
  //WORD parent_bone_index; // (0xFFFF)
  //WORD tail_pos_bone_index; // tail(0xFFFF) // 1
  //BYTE bone_type; // 
  //WORD ik_parent_bone_index; // IK(IK0)
  //float bone_head_pos[3]; // x, y, z // 
  Bone = class Bone {
    constructor(buffer, view, offset) {
      var tmp;
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
      offset += size_Uint8 * 20;
      this.parent_bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      this.tail_pos_bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      this.type = view.getUint8(offset);
      offset += size_Uint8;
      this.ik_parent_bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.head_pos = new Float32Array(tmp);
    }

  };

  Bone.size = size_Uint8 * 21 + size_Uint16 * 3 + size_Float32 * 3;

  //http://blog.goo.ne.jp/torisu_tetosuki/e/445cbbbe75c4b2622c22b473a27aaae9
  //WORD ik_bone_index; // IK
  //WORD ik_target_bone_index; // IK // IK
  //BYTE ik_chain_length; // IK()
  //WORD iterations; //  // IK1
  //float control_weight; // IK // IK2
  //WORD ik_child_bone_index[ik_chain_length]; // IK
  IK = class IK {
    constructor(buffer, view, offset) {
      var chain_length, i;
      this.bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      this.target_bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      chain_length = view.getUint8(offset);
      offset += size_Uint8;
      this.iterations = view.getUint16(offset, true);
      offset += size_Uint16;
      this.control_weight = view.getFloat32(offset, true);
      offset += size_Float32;
      this.child_bones = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = chain_length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(view.getUint16(offset + size_Uint16 * i, true));
        }
        return results;
      })();
    }

    getSize() {
      return size_Uint16 * 3 + size_Uint8 + size_Float32 + size_Uint16 * this.child_bones.length;
    }

  };

  //http://blog.goo.ne.jp/torisu_tetosuki/e/8553151c445d261e122a3a31b0f91110
  Morph = class Morph {
    constructor(buffer, view, offset) {
      var data, i, vert_count;
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
      offset += size_Uint8 * 20;
      vert_count = view.getUint32(offset, true);
      offset += size_Uint32;
      this.type = view.getUint8(offset);
      offset += size_Uint8;
      this.vert_data = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = vert_count; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          data = {};
          data.index = view.getUint32(offset, true);
          offset += size_Uint32;
          data.x = view.getFloat32(offset, true);
          offset += size_Float32;
          data.y = view.getFloat32(offset, true);
          offset += size_Float32;
          data.z = -view.getFloat32(offset, true);
          offset += size_Float32; // left->right handed system
          results.push(data);
        }
        return results;
      })();
    }

    getSize() {
      return size_Uint8 * 21 + size_Uint32 + (size_Uint32 + size_Float32 * 3) * this.vert_data.length;
    }

  };

  //http://blog.goo.ne.jp/torisu_tetosuki/e/1e25fc196f2d7a7798f5cea87a942943
  //char rigidbody_name[20]; //  // 
  //WORD rigidbody_rel_bone_index; //  // 03 00 == 3 // 
  //BYTE rigidbody_group_index; //  // 00
  //WORD rigidbody_group_target; //  // 0xFFFF // 38 FE
  //BYTE shape_type; // (0:1:2:) // 00 // 
  //float shape_w; // () // CD CC CC 3F // 1.6
  //float shape_h; //  // CD CC CC 3D // 0.1
  //float shape_d; //  // CD CC CC 3D // 0.1
  //float pos_pos[3]; // (x, y, z)
  //float pos_rot[3]; // (rad(x), rad(y), rad(z))
  //float rigidbody_weight; //  // 00 00 80 3F // 1.0
  //float rigidbody_pos_dim; //  // 00 00 00 00
  //float rigidbody_rot_dim; //  // 00 00 00 00
  //float rigidbody_recoil; //  // 00 00 00 00
  //float rigidbody_friction; //  // 00 00 00 00
  //BYTE rigidbody_type; // (0:Bone1:2:(Bone)) // 00 // Bone
  RigidBody = class RigidBody {
    constructor(buffer, view, offset) {
      var tmp;
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
      offset += size_Uint8 * 20;
      this.rel_bone_index = view.getUint16(offset, true);
      offset += size_Uint16;
      this.group_index = view.getUint8(offset);
      offset += size_Uint8;
      this.group_target = view.getUint8(offset);
      offset += size_Uint8;
      this.shape_type = view.getUint8(offset, true);
      offset += size_Uint8;
      this.shape_w = view.getFloat32(offset, true);
      offset += size_Float32;
      this.shape_h = view.getFloat32(offset, true);
      offset += size_Float32;
      this.shape_d = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.pos = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.rot = new Float32Array(tmp);
      this.weight = view.getFloat32(offset, true);
      offset += size_Float32;
      this.pos_dim = view.getFloat32(offset, true);
      offset += size_Float32;
      this.rot_dim = view.getFloat32(offset, true);
      offset += size_Float32;
      this.recoil = view.getFloat32(offset, true);
      offset += size_Float32;
      this.friction = view.getFloat32(offset, true);
      offset += size_Float32;
      this.type = view.getUint8(offset);
      offset += size_Uint8;
    }

  };

  RigidBody.size = size_Uint8 * 23 + size_Uint16 * 2 + size_Float32 * 14;

  //http://blog.goo.ne.jp/torisu_tetosuki/e/b96dc839798f251ac235138b992a4481
  //char joint_name[20]; //  // 1
  //DWORD joint_rigidbody_a; // A
  //DWORD joint_rigidbody_b; // B
  //float joint_pos[3]; // (x, y, z) // 
  //float joint_rot[3]; // (rad(x), rad(y), rad(z))
  //float constrain_pos_1[3]; // 1(x, y, z)
  //float constrain_pos_2[3]; // 2(x, y, z)
  //float constrain_rot_1[3]; // 1(rad(x), rad(y), rad(z))
  //float constrain_rot_2[3]; // 2(rad(x), rad(y), rad(z))
  //float spring_pos[3]; // (x, y, z)
  //float spring_rot[3]; // (rad(x), rad(y), rad(z))
  Joint = class Joint {
    constructor(buffer, view, offset) {
      var tmp;
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
      offset += size_Uint8 * 20;
      this.rigidbody_a = view.getUint32(offset, true);
      offset += size_Uint32;
      this.rigidbody_b = view.getUint32(offset, true);
      offset += size_Uint32;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.pos = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.rot = new Float32Array(tmp);
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.constrain_pos_1 = new Float32Array(tmp);
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.constrain_pos_2 = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.constrain_rot_1 = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.constrain_rot_2 = new Float32Array(tmp);
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.spring_pos = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.spring_rot = new Float32Array(tmp);
    }

  };

  Joint.size = size_Int8 * 20 + size_Uint32 * 2 + size_Float32 * 24;

  // see http://blog.goo.ne.jp/torisu_tetosuki/e/bc9f1c4d597341b394bd02b64597499d

  // some shorthands
  size_Uint8 = Uint8Array.BYTES_PER_ELEMENT;

  size_Uint32 = Uint32Array.BYTES_PER_ELEMENT;

  size_Float32 = Float32Array.BYTES_PER_ELEMENT;

  slice = Array.prototype.slice;

  this.MMD.Motion = class Motion { // export to top level
    constructor(path) {
      this.path = path;
    }

    load(callback) {
      var xhr;
      xhr = new XMLHttpRequest();
      xhr.open('GET', this.path, true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = () => {
        console.time('parse');
        this.parse(xhr.response);
        console.timeEnd('parse');
        return callback();
      };
      return xhr.send();
    }

    parse(buffer) {
      var length, offset, view;
      length = buffer.byteLength;
      view = new DataView(buffer, 0);
      offset = 0;
      offset = this.checkHeader(buffer, view, offset);
      offset = this.getModelName(buffer, view, offset);
      offset = this.getBoneMotion(buffer, view, offset);
      offset = this.getMorphMotion(buffer, view, offset);
      offset = this.getCameraMotion(buffer, view, offset);
      offset = this.getLightMotion(buffer, view, offset);
      return offset = this.getSelfShadowMotion(buffer, view, offset);
    }

    checkHeader(buffer, view, offset) {
      if ('Vocaloid Motion Data 0002\0\0\0\0\0' !== String.fromCharCode.apply(null, slice.call(new Uint8Array(buffer, offset, 30)))) {
        throw 'File is not VMD';
      }
      return offset += 30 * size_Uint8;
    }

    getModelName(buffer, view, offset) {
      this.model_name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
      return offset += size_Uint8 * 20;
    }

    getBoneMotion(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.bone = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new BoneMotion(buffer, view, offset + i * BoneMotion.size));
        }
        return results;
      })();
      return offset += length * BoneMotion.size;
    }

    getMorphMotion(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.morph = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new MorphMotion(buffer, view, offset + i * MorphMotion.size));
        }
        return results;
      })();
      return offset += length * MorphMotion.size;
    }

    getCameraMotion(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.camera = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new CameraMotion(buffer, view, offset + i * CameraMotion.size));
        }
        return results;
      })();
      return offset += length * CameraMotion.size;
    }

    getLightMotion(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.light = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new LightMotion(buffer, view, offset + i * LightMotion.size));
        }
        return results;
      })();
      return offset += length * LightMotion.size;
    }

    getSelfShadowMotion(buffer, view, offset) {
      var i, length;
      length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.selfshadow = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          results.push(new SelfShadowMotion(buffer, view, offset + i * SelfShadowMotion.size));
        }
        return results;
      })();
      return offset += length * SelfShadowMotion.size;
    }

  };

  //char BoneName[15];
  //DWORD FlameNo;
  //float Location[3];
  //float Rotatation[4]; // Quaternion
  //BYTE Interpolation[64]; // [4][4][4]
  BoneMotion = class BoneMotion {
    constructor(buffer, view, offset) {
      var i, k, tmp;
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 15));
      offset += size_Uint8 * 15;
      this.frame = view.getUint32(offset, true);
      offset += size_Uint32;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.location = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[3] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.rotation = new Float32Array(tmp);
      for (i = k = 0; k < 64; i = ++k) {
        tmp[i] = view.getUint8(offset, true);
        offset += size_Uint8;
      }
      this.interpolation = new Uint8Array(tmp);
    }

  };

  BoneMotion.size = size_Uint8 * (15 + 64) + size_Uint32 + size_Float32 * 7;

  //char SkinName[15];
  //DWORD FlameNo;
  //float Weight;
  MorphMotion = class MorphMotion {
    constructor(buffer, view, offset) {
      this.name = sjisArrayToString(new Uint8Array(buffer, offset, 15));
      offset += size_Uint8 * 15;
      this.frame = view.getUint32(offset, true);
      offset += size_Uint32;
      this.weight = view.getFloat32(offset, true);
      offset += size_Float32;
    }

  };

  MorphMotion.size = size_Uint8 * 15 + size_Uint32 + size_Float32;

  //DWORD FlameNo;
  //float Length; // -()
  //float Location[3];
  //float Rotation[3]; //  // X
  //BYTE Interpolation[24]; // [6][4]()
  //DWORD ViewingAngle;
  //BYTE Perspective; // 0:on 1:off
  CameraMotion = class CameraMotion {
    constructor(buffer, view, offset) {
      var i, k, tmp;
      this.frame = view.getUint32(offset, true);
      offset += size_Uint32;
      this.distance = -view.getFloat32(offset, true);
      offset += size_Float32;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.location = new Float32Array(tmp);
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.rotation = new Float32Array(tmp);
      for (i = k = 0; k < 24; i = ++k) {
        tmp[i] = view.getUint8(offset, true);
        offset += size_Uint8;
      }
      this.interpolation = new Uint8Array(tmp);
      this.view_angle = view.getUint32(offset, true);
      offset += size_Uint32;
      this.noPerspective = view.getUint8(offset, true);
      offset += size_Uint8;
    }

  };

  CameraMotion.size = size_Float32 * 7 + size_Uint8 * 25 + size_Float32 * 2;

  //DWORD FlameNo;
  //float RGB[3]; // RGB/256
  //float Location[3];
  LightMotion = class LightMotion {
    constructor(buffer, view, offset) {
      var tmp;
      this.frame = view.getUint32(offset, true);
      offset += size_Uint32;
      tmp = [];
      tmp[0] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32;
      this.color = new Float32Array(tmp);
      tmp = [];
      tmp[0] = -view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[1] = -view.getFloat32(offset, true);
      offset += size_Float32;
      tmp[2] = view.getFloat32(offset, true);
      offset += size_Float32; // left->right handed system
      this.location = new Float32Array(tmp);
    }

  };

  LightMotion.size = size_Float32 * 6 + size_Uint32;

  //DWORD FlameNo;
  //BYTE Mode; // 00-02
  //float Distance; // 0.1 - (dist * 0.00001)
  SelfShadowMotion = class SelfShadowMotion {
    constructor(buffer, view, offset) {
      this.frame = view.getUint32(offset, true);
      offset += size_Uint32;
      this.mode = view.getUint8(offset, true);
      offset += size_Uint8;
      this.distance = view.getFloat32(offset, true);
      offset += size_Float32;
    }

  };

  SelfShadowMotion.size = size_Float32 + size_Uint8 + size_Float32;

  MMD.MotionManager = class MotionManager {
    constructor() {
      this.modelMotions = [];
      this.cameraMotion = [];
      this.cameraFrames = [];
      this.lightMotion = [];
      this.lightFrames = [];
      this.lastFrame = 0;
      return;
    }

    addModelMotion(model, motion, merge_flag, frame_offset) {
      var i, k, len, mm, ref;
      ref = this.modelMotions;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        mm = ref[i];
        if (model === mm.model) {
          break;
        }
      }
      if (i === this.modelMotions.length) {
        mm = new ModelMotion(model);
        this.modelMotions.push(mm);
      }
      mm.addBoneMotion(motion.bone, merge_flag, frame_offset);
      mm.addMorphMotion(motion.morph, merge_flag, frame_offset);
      this.lastFrame = mm.lastFrame;
    }

    getModelFrame(model, frame) {
      var i, k, len, mm, ref;
      ref = this.modelMotions;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        mm = ref[i];
        if (model === mm.model) {
          break;
        }
      }
      if (i === this.modelMotions.length) {
        return {};
      }
      return {
        bones: mm.getBoneFrame(frame),
        morphs: mm.getMorphFrame(frame)
      };
    }

    addCameraLightMotion(motion, merge_flag, frame_offset) {
      this.addCameraMotion(motion.camera, merge_flag, frame_offset);
      this.addLightMotion(motion.light, merge_flag, frame_offset);
    }

    addCameraMotion(camera, merge_flag, frame_offset) {
      var c, frame, k, len;
      if (camera.length === 0) {
        return;
      }
      if (!merge_flag) {
        this.cameraMotion = [];
        this.cameraFrames = [];
      }
      frame_offset = frame_offset || 0;
      for (k = 0, len = camera.length; k < len; k++) {
        c = camera[k];
        frame = c.frame + frame_offset;
        this.cameraMotion[frame] = c;
        this.cameraFrames.push(frame);
        if (this.lastFrame < frame) {
          this.lastFrame = frame;
        }
      }
      this.cameraFrames = this.cameraFrames.sort(function(a, b) {
        return a - b;
      });
    }

    addLightMotion(light, merge_flag, frame_offset) {
      var frame, k, l, len;
      if (light.length === 0) {
        return;
      }
      if (!merge_flag) {
        this.lightMotion = [];
        this.lightFrames = [];
      }
      frame_offset = frame_offset || 0;
      for (k = 0, len = light.length; k < len; k++) {
        l = light[k];
        frame = l.frame + frame_offset;
        this.lightMotion[frame] = l;
        this.lightFrames.push(frame);
        if (this.lastFrame < frame) {
          this.lastFrame = frame;
        }
      }
      this.lightFrames = this.lightFrames.sort(function(a, b) {
        return a - b;
      });
    }

    getCameraFrame(frame) {
      var bez, cache, camera, frac, frames, idx, lastFrame, n, next, p, prev, timeline;
      if (!this.cameraMotion.length) {
        return null;
      }
      timeline = this.cameraMotion;
      frames = this.cameraFrames;
      lastFrame = frames[frames.length - 1];
      if (lastFrame <= frame) {
        camera = timeline[lastFrame];
      } else {
        idx = previousRegisteredFrame(frames, frame);
        p = frames[idx];
        n = frames[idx + 1];
        frac = fraction(frame, p, n);
        prev = timeline[p];
        next = timeline[n];
        cache = [];
        bez = function(i) {
          var X1, X2, Y1, Y2, id;
          X1 = next.interpolation[i * 4];
          X2 = next.interpolation[i * 4 + 1];
          Y1 = next.interpolation[i * 4 + 2];
          Y2 = next.interpolation[i * 4 + 3];
          id = X1 | (X2 << 8) | (Y1 << 16) | (Y2 << 24);
          if (cache[id] != null) {
            return cache[id];
          }
          if (X1 === Y1 && X2 === Y2) {
            return cache[id] = frac;
          }
          return cache[id] = bezierp(X1 / 127, X2 / 127, Y1 / 127, Y2 / 127, frac);
        };
        camera = {
          location: vec3.createLerp3(prev.location, next.location, [bez(0), bez(1), bez(2)]),
          rotation: vec3.createLerp(prev.rotation, next.rotation, bez(3)),
          distance: lerp1(prev.distance, next.distance, bez(4)),
          view_angle: lerp1(prev.view_angle, next.view_angle, bez(5))
        };
      }
      return camera;
    }

    getLightFrame(frame) {
      var frac, frames, idx, lastFrame, light, n, next, p, prev, timeline;
      if (!this.lightMotion.length) {
        return null;
      }
      timeline = this.lightMotion;
      frames = this.lightFrames;
      lastFrame = frames[frames.length - 1];
      if (lastFrame <= frame) {
        light = timeline[lastFrame];
      } else {
        idx = previousRegisteredFrame(frames, frame);
        p = frames[idx];
        n = frames[idx + 1];
        frac = fraction(frame, p, n);
        prev = timeline[p];
        next = timeline[n];
        light = {
          color: vec3.createLerp(prev.color, next.color, frac),
          location: vec3.lerp(prev.location, next.location, frac)
        };
      }
      return light;
    }

  };

  ModelMotion = class ModelMotion {
    constructor(model1) {
      this.model = model1;
      this.boneMotions = {};
      this.boneFrames = {};
      this.morphMotions = {};
      this.morphFrames = {};
      this.lastFrame = 0;
    }

    addBoneMotion(bone, merge_flag, frame_offset) {
      var b, frame, k, len, name;
      if (!merge_flag) {
        this.boneMotions = {};
        this.boneFrames = {};
      }
      frame_offset = frame_offset || 0;
      for (k = 0, len = bone.length; k < len; k++) {
        b = bone[k];
        if (!this.boneMotions[b.name]) {
          this.boneMotions[b.name] = [
            {
              location: vec3.create(),
              rotation: quat4.create([0,
            0,
            0,
            1])
            }
          ];
        }
        frame = b.frame + frame_offset;
        this.boneMotions[b.name][frame] = b;
        if (this.lastFrame < frame) {
          this.lastFrame = frame;
        }
      }
      for (name in this.boneMotions) {
        this.boneFrames[name] = (this.boneFrames[name] || []).concat(Object.keys(this.boneMotions[name]).map(Number)).sort(function(a, b) {
          return a - b;
        });
      }
    }

    addMorphMotion(morph, merge_flag, frame_offset) {
      var frame, k, len, m, name;
      if (!merge_flag) {
        this.morphMotions = {};
        this.morphFrames = {};
      }
      frame_offset = frame_offset || 0;
      for (k = 0, len = morph.length; k < len; k++) {
        m = morph[k];
        if (m.name === 'base') {
          continue;
        }
        if (!this.morphMotions[m.name]) {
          this.morphMotions[m.name] = [0];
        }
        frame = m.frame + frame_offset;
        this.morphMotions[m.name][frame] = m.weight;
        if (this.lastFrame < frame) {
          this.lastFrame = frame;
        }
      }
      for (name in this.morphMotions) {
        this.morphFrames[name] = (this.morphFrames[name] || []).concat(Object.keys(this.morphMotions[name]).map(Number)).sort(function(a, b) {
          return a - b;
        });
      }
    }

    getBoneFrame(frame) {
      var bez, bones, cache, frac, frames, idx, lastFrame, n, name, next, p, prev, r, rotation, timeline;
      bones = {};
      for (name in this.boneMotions) {
        timeline = this.boneMotions[name];
        frames = this.boneFrames[name];
        lastFrame = frames[frames.length - 1];
        if (lastFrame <= frame) {
          bones[name] = timeline[lastFrame];
        } else {
          idx = previousRegisteredFrame(frames, frame);
          p = frames[idx];
          n = frames[idx + 1];
          frac = fraction(frame, p, n);
          prev = timeline[p];
          next = timeline[n];
          cache = [];
          bez = function(i) {
            var X1, X2, Y1, Y2, id;
            X1 = next.interpolation[i * 4];
            X2 = next.interpolation[i * 4 + 1];
            Y1 = next.interpolation[i * 4 + 2];
            Y2 = next.interpolation[i * 4 + 3];
            id = X1 | (X2 << 8) | (Y1 << 16) | (Y2 << 24);
            if (cache[id] != null) {
              return cache[id];
            }
            if (X1 === Y1 && X2 === Y2) {
              return cache[id] = frac;
            }
            return cache[id] = bezierp(X1 / 127, X2 / 127, Y1 / 127, Y2 / 127, frac);
          };
          if (quat4.dot(prev.rotation, next.rotation) >= 0) {
            rotation = quat4.createSlerp(prev.rotation, next.rotation, bez(3));
          } else {
            r = prev.rotation;
            rotation = quat4.createSlerp([-r[0], -r[1], -r[2], -r[3]], next.rotation, bez(3));
          }
          bones[name] = {
            location: vec3.createLerp3(prev.location, next.location, [bez(0), bez(1), bez(2)]),
            rotation: rotation
          };
        }
      }
      return bones;
    }

    getMorphFrame(frame) {
      var frac, frames, idx, lastFrame, morphs, n, name, next, p, prev, timeline;
      morphs = {};
      for (name in this.morphMotions) {
        timeline = this.morphMotions[name];
        frames = this.morphFrames[name];
        lastFrame = frames[frames.length - 1];
        if (lastFrame <= frame) {
          morphs[name] = timeline[lastFrame];
        } else {
          idx = previousRegisteredFrame(frames, frame);
          p = frames[idx];
          n = frames[idx + 1];
          frac = fraction(frame, p, n);
          prev = timeline[p];
          next = timeline[n];
          morphs[name] = lerp1(prev, next, frac);
        }
      }
      return morphs;
    }

  };

  // utils
  previousRegisteredFrame = function(frames, frame) {
    /*
      'frames' is key frames registered, 'frame' is the key frame I'm enquiring about
      ex. frames: [0,10,20,30,40,50], frame: 15
      now I want to find the numbers 10 and 20, namely the ones before 15 and after 15
      I'm doing a bisection search here.
    */
    var delta, idx;
    idx = 0;
    delta = frames.length;
    while (true) {
      delta = (delta >> 1) || 1;
      if (frames[idx] <= frame) {
        if (delta === 1 && frames[idx + 1] > frame) {
          break;
        }
        idx += delta;
      } else {
        idx -= delta;
        if (delta === 1 && frames[idx] <= frame) {
          break;
        }
      }
    }
    return idx;
  };

  fraction = function(x, x0, x1) {
    return (x - x0) / (x1 - x0);
  };

  lerp1 = function(x0, x1, a) {
    return x0 + a * (x1 - x0);
  };

  bezierp = function(x1, x2, y1, y2, x) {
    var t, tt, v;
    /*
      interpolate using Bezier curve (http://musashi.or.tv/fontguide_doc3.htm)
      Bezier curve is parametrized by t (0 <= t <= 1)
        x = s^3 x_0 + 3 s^2 t x_1 + 3 s t^2 x_2 + t^3 x_3
        y = s^3 y_0 + 3 s^2 t y_1 + 3 s t^2 y_2 + t^3 y_3
      where s is defined as s = 1 - t.
      Especially, for MMD, (x_0, y_0) = (0, 0) and (x_3, y_3) = (1, 1), so
        x = 3 s^2 t x_1 + 3 s t^2 x_2 + t^3
        y = 3 s^2 t y_1 + 3 s t^2 y_2 + t^3
      Now, given x, find t by bisection method (http://en.wikipedia.org/wiki/Bisection_method)
      i.e. find t such that f(t) = 3 s^2 t x_1 + 3 s t^2 x_2 + t^3 - x = 0
      One thing to note here is that f(t) is monotonically increasing in the range [0,1]
      Therefore, when I calculate f(t) for the t I guessed,
      Finally find y for the t.
    */
    //Adopted from MMDAgent
    t = x;
    while (true) {
      v = ipfunc(t, x1, x2) - x;
      if (v * v < 0.0000001) { // Math.abs(v) < 0.0001
        break;
      }
      tt = ipfuncd(t, x1, x2);
      if (tt === 0) {
        break;
      }
      t -= v / tt;
    }
    return ipfunc(t, y1, y2);
  };

  ipfunc = function(t, p1, p2) {
    return (1 + 3 * p1 - 3 * p2) * t * t * t + (3 * p2 - 6 * p1) * t * t + 3 * p1 * t;
  };

  ipfuncd = function(t, p1, p2) {
    return (3 + 9 * p1 - 9 * p2) * t * t + (6 * p2 - 12 * p1) * t + 3 * p1;
  };

  MMD.ShadowMap = class ShadowMap {
    constructor(mmd) {
      this.mmd = mmd;
      this.framebuffer = this.texture = null;
      this.width = this.height = 2048;
      this.viewBroadness = 0.6;
      this.debug = false;
      this.initFramebuffer();
    }

    initFramebuffer() {
      var gl, renderbuffer;
      gl = this.mmd.gl;
      this.framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    computeMatrices() {
      var cameraPosition, center, cx, cy, lengthScale, lightDirection, size, viewMatrix;
      // from mmd's vectors and matrices, calculate the "light" space's transform matrices
      center = vec3.create(this.mmd.center); // center of view in world space
      lightDirection = vec3.createNormalize(this.mmd.lightDirection); // becomes the camera direction in light space
      vec3.add(lightDirection, center);
      cameraPosition = vec3.create(this.mmd.cameraPosition);
      lengthScale = vec3.lengthBetween(cameraPosition, center);
      size = lengthScale * this.viewBroadness; // size of shadowmap
      viewMatrix = mat4.lookAt(lightDirection, center, [0, 1, 0]);
      this.mvMatrix = mat4.createMultiply(viewMatrix, this.mmd.modelMatrix);
      mat4.multiplyVec3(viewMatrix, center); // transform center in view space
      cx = center[0];
      cy = center[1];
      this.pMatrix = mat4.ortho(cx - size, cx + size, cy - size, cy + size, -size, size); // orthographic projection; near can be negative
    }

    beforeRender() {
      var gl, program;
      gl = this.mmd.gl;
      program = this.mmd.program;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.viewport(0, 0, this.width, this.height);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.uniform1i(program.uGenerateShadowMap, true);
      gl.uniformMatrix4fv(program.uMVMatrix, false, this.mvMatrix);
      gl.uniformMatrix4fv(program.uPMatrix, false, this.pMatrix);
    }

    afterRender() {
      var gl, program;
      gl = this.mmd.gl;
      program = this.mmd.program;
      gl.uniform1i(program.uGenerateShadowMap, false);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (this.debug) {
        this.debugTexture();
      }
    }

    getLightMatrix() {
      var lightMatrix;
      // display matrix transforms projection space to screen space. in fragment shader screen coordinates are available as gl_FragCoord
      // http://www.c3.club.kyutech.ac.jp/gamewiki/index.php?3D%BA%C2%C9%B8%CA%D1%B4%B9
      lightMatrix = mat4.createMultiply(this.pMatrix, this.mvMatrix);
      mat4.applyScale(lightMatrix, [0.5, 0.5, 0.5]);
      mat4.applyTranslate(lightMatrix, [0.5, 0.5, 0.5]);
      return lightMatrix;
    }

    debugTexture() {
      var canvas, ctx, data, gl, i, imageData, k, pixelarray, ref;
      gl = this.mmd.gl;
      pixelarray = new Uint8Array(this.width * this.height * 4);
      gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixelarray);
      canvas = document.getElementById('shadowmap');
      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.id = 'shadowmap';
        canvas.width = this.width;
        canvas.height = this.height;
        canvas.style.border = 'solid black 1px';
        canvas.style.width = this.mmd.width + 'px';
        canvas.style.height = this.mmd.height + 'px';
        document.body.appendChild(canvas);
      }
      ctx = canvas.getContext('2d');
      imageData = ctx.getImageData(0, 0, this.width, this.height);
      data = imageData.data;
      for (i = k = 0, ref = data.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        data[i] = pixelarray[i];
      }
      return ctx.putImageData(imageData, 0, 0);
    }

    getTexture() {
      return this.texture;
    }

  };

  MMD.TextureManager = class TextureManager {
    constructor(mmd) {
      this.mmd = mmd;
      this.store = {};
      this.pendingCount = 0;
    }

    get(type, url) {
      var gl, texture;
      texture = this.store[url];
      if (texture) {
        return texture;
      }
      gl = this.mmd.gl;
      texture = this.store[url] = gl.createTexture();
      loadImage(url, (img) => {
        img = checkSize(img);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        if (type === 'toon') {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        if (this.onload) {
          this.onload(img);
        }
        return --this.pendingCount;
      });
      this.pendingCount++;
      return texture;
    }

  };

  // utils
  checkSize = function(img) {
    var canv, h, size, w;
    w = img.naturalWidth;
    h = img.naturalHeight;
    size = 1 << (Math.log(Math.min(w, h)) / Math.LN2 | 0); // largest 2^n integer that don't exceed w or h
    if (w !== h || w !== size) {
      canv = document.createElement('canvas');
      canv.height = canv.width = size;
      canv.getContext('2d').drawImage(img, 0, 0, w, h, 0, 0, size, size);
      img = canv;
    }
    return img;
  };

  loadImage = function(url, callback) {
    var img;
    img = new Image();
    img.onload = function() {
      return callback(img);
    };
    img.onerror = function() {
      return alert('failed to load image: ' + url);
    };
    img.src = url;
    return img;
  };

  MMD.VertexShaderSource = `
uniform mat4 uMVMatrix; // model-view matrix (model -> view space)
uniform mat4 uPMatrix; // projection matrix (view -> projection space)
uniform mat4 uNMatrix; // normal matrix (inverse of transpose of model-view matrix)

uniform mat4 uLightMatrix; // mvpdMatrix of light space (model -> display space)

attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;
attribute float aVertexEdge; // 0 or 1. 1 if the vertex has an edge. (becuase we can't pass bool to attributes)

attribute float aBoneWeight;
attribute vec3 aVectorFromBone1;
attribute vec3 aVectorFromBone2;
attribute vec4 aBone1Rotation;
attribute vec4 aBone2Rotation;
attribute vec3 aBone1Position;
attribute vec3 aBone2Position;

attribute vec3 aMultiPurposeVector;

varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vTextureCoord;
varying vec4 vLightCoord; // coordinate in light space; to be mapped onto shadow map

uniform float uEdgeThickness;
uniform bool uEdge;

uniform bool uGenerateShadowMap;

uniform bool uSelfShadow;

uniform bool uAxis;
uniform bool uCenterPoint;

vec3 qtransform(vec4 q, vec3 v) {
  return v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);
}

void main() {
  vec3 position;
  vec3 normal;

  if (uAxis || uCenterPoint) {

    position = aMultiPurposeVector;

  } else {

    float weight = aBoneWeight;
    vec3 morph = aMultiPurposeVector;

    position = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;
    normal = qtransform(aBone1Rotation, aVertexNormal);

    if (weight < 0.99) {
      vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;
      vec3 n2 = qtransform(aBone2Rotation, normal);

      position = mix(p2, position, weight);
      normal = normalize(mix(n2, normal, weight));
    }
  }

  // return vertex point in projection space
  gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);

  if (uCenterPoint) {
    gl_Position.z = 0.0; // always on top
    gl_PointSize = 16.0;
  }

  if (uGenerateShadowMap || uAxis || uCenterPoint) return;

  // for fragment shader
  vTextureCoord = aTextureCoord;
  vPosition = (uMVMatrix * vec4(position, 1.0)).xyz;
  vNormal = (uNMatrix * vec4(normal, 1.0)).xyz;

  if (uSelfShadow) {
    vLightCoord = uLightMatrix * vec4(position, 1.0);
  }

  if (uEdge) {
    vec4 pos = gl_Position;
    vec4 pos2 = uPMatrix * uMVMatrix * vec4(position + normal, 1.0);
    vec4 norm = normalize(pos2 - pos);
    gl_Position = pos + norm * uEdgeThickness * aVertexEdge * pos.w; // scale by pos.w to prevent becoming thicker when zoomed
    return;
  }
}
`;

}).call(this);
